## 最小化局部变量的scope
1. 用时再声明
2. 几乎每个局部变量都需要初始化
3. 坚持单一职责原则，保持方法小而精。

## for-each 循环由于传统的遍历方法
三种场景需要使用传统的Iterator遍历
1. 遍历过程中需要移除元素
2. 需要替换元素
3. 并行遍历

## 了解然后再使用库函数
1. Random 函数并不是真随机的
2. 站在巨人的肩膀上

## 避免使用float，double，如果想获得精确值。
1. 使用BigDecimal，int，long 处理与钱相关的计算

## 推荐使用原始类型，而不是包装类型
1. 使用==比较包装类型经常是错误的
2. unboxing可能导致空指针

## 如果有其他合适的类型可选，避免使用strings
1. 使用private static member class代替聚合字符串。比如：String component=className+"#"+i.next()
  因为解析字符串是一个复杂的操作，不能自定义equals，compare等方法

## 注意字符串连接的性能
1. String是不可变类，使用连接操作符，需要copy字符
2. 使用StringBuilder

## 面向接口编程，使用接口类型

## 接口优于反射
反射的代价
1. 失去编译时的类型检查的好处
2. 反射代码繁杂冗长，不易读
3. 性能有损失
补偿措施，因为很多时候，不得不用反射
1. 通过反射创建实例，但是通过接口正常的访问对象

## 正确的使用native方法
1. 如果单纯为了提高性能，不建议使用native方法，因为现代jvm的性能已经优化的很好了，性能也已经很高了。

## 正确的优化
1. 很多计算机罪恶都是假借效率的名义被做出的，往往这种效率是没有必要的。这比其他原因都多，甚至比盲目优化更多
2. 我们应该忘记小的效率，有种说法，97%的情况下，不成熟的优化是罪恶的根源
3. 在优化时，应该遵循如下规则：
  3.1 不要进行优化
  3.2 （仅对专家适用）直到你有一个完美的清晰并且未经优化的方案前，不要做优化。
4. 坚持写好的程序而不是最快的程序
5. 努力避免会限制性能的设计方案
6. 考虑API设计方案的性能
7. 曲解api去获取好的性能是个坏主意
8. 每次优化前后都要对API进行测试

## 坚持通用的命名传统
